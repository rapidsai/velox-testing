#!/usr/bin/env bash
# SPDX-FileCopyrightText: Copyright (c) 2026, NVIDIA CORPORATION & AFFILIATES. All rights reserved.
# SPDX-License-Identifier: Apache-2.0
#
# Record conflict resolutions to the resolutions bank (hunk-based format).
#
# Workflow:
#   1. Run staging script with --dump-conflicts to generate a conflict report
#   2. Edit the .conflict file(s) to resolve conflicts (remove markers)
#   3. Run this script pointing at the report directory
#
# Usage:
#   ./scripts/record_resolution.sh <report-dir> [--hint <hint>] [--force]
#
# Examples:
#   ./scripts/record_resolution.sh staging-conflict-report/PR-15825
#   ./scripts/record_resolution.sh staging-conflict-report/PR-15825 --hint "decimal+exchange"
#   ./scripts/record_resolution.sh staging-conflict-report/pairwise/PR-15825+PR-16212 --force

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "${SCRIPT_DIR}/.." && pwd)"
RESOLUTIONS_DIR="${PROJECT_ROOT}/resolutions.d"

log() { echo "$@" >&2; }
die() { log "ERROR: $*"; exit 1; }
warn() { log "WARNING: $*"; }

REPORT_DIR=""
HINT=""
FORCE="false"

usage() {
  cat <<EOF
Usage: $(basename "$0") <report-dir> [--hint <hint>] [--force]

Record resolved conflict files into the resolutions bank.

Arguments:
  report-dir              Path to conflict report directory (from --dump-conflicts)

Options:
  --hint <hint>           Human-readable hint for the .resol filename (auto-generated if omitted)
  --force                 Overwrite existing resolutions for the same conflict
  -h, --help              Show this help

The report directory should contain .conflict, .ours, .base, .theirs, and .filepath
files generated by the staging script's --dump-conflicts option.
When available, CONFLICT_CONTEXT.txt provides base/source branch details.

Edit the .conflict file(s) to resolve conflicts before running this script.
The original conflict is reconstructed from .base/.ours/.theirs for hunk extraction.
EOF
}

parse_args() {
  if [[ $# -lt 1 ]]; then
    usage
    exit 1
  fi

  if [[ "${1:-}" == "-h" || "${1:-}" == "--help" ]]; then
    usage
    exit 0
  fi

  REPORT_DIR="$1"
  shift

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --hint) HINT="$2"; shift 2 ;;
      --force) FORCE="true"; shift ;;
      -h|--help) usage; exit 0 ;;
      *) die "Unknown option: $1" ;;
    esac
  done

  if [[ ! -d "${REPORT_DIR}" ]]; then
    die "Report directory not found: ${REPORT_DIR}"
  fi
}

# Check if a line from the resolved file is a real leftover conflict marker
# by verifying it does NOT appear in .ours or .theirs
is_leftover_marker() {
  local line="$1"
  local ours_file="$2"
  local theirs_file="$3"

  if grep -qFx "${line}" "${ours_file}" 2>/dev/null; then
    return 1  # found in ours — legitimate source code
  fi
  if grep -qFx "${line}" "${theirs_file}" 2>/dev/null; then
    return 1  # found in theirs — legitimate source code
  fi
  return 0  # not found in either — leftover conflict marker
}

# Validate resolved file for leftover conflict markers.
validate_markers() {
  local resolved_file="$1"
  local ours_file="$2"
  local theirs_file="$3"
  local filepath="$4"
  local found_leftover=0

  for marker in '<<<<<<<' '|||||||' '=======' '>>>>>>>'; do
    while IFS= read -r line; do
      [[ -z "${line}" ]] && continue
      if is_leftover_marker "${line}" "${ours_file}" "${theirs_file}"; then
        warn "  leftover marker in ${filepath}: ${line}"
        found_leftover=1
      fi
    done < <(grep -F "${marker}" "${resolved_file}" 2>/dev/null || true)
  done

  return "${found_leftover}"
}

# Auto-generate hint from report directory name
auto_hint() {
  local report_dir="$1"
  local dir_name
  dir_name="$(basename "${report_dir}")"

  # PR dirs: "PR-15825" → "pr15825", "PR-15825+PR-16212" → "pr15825+pr16212"
  # Additional repo dirs: "mattgara_velox-cudf_exchange_..." → used as-is
  echo "${dir_name}" | sed 's/PR-/pr/g'
}

# Find next available NNNN index for .resol files
next_resol_index() {
  local max_idx=0
  if [[ -d "${RESOLUTIONS_DIR}" ]]; then
    local f
    while IFS= read -r f; do
      [[ -z "${f}" ]] && continue
      [[ -f "${f}" ]] || continue
      local base
      base="$(basename "${f}")"
      local idx_str="${base%%-*}"
      if [[ ! "${idx_str}" =~ ^[0-9]+$ ]]; then
        continue
      fi
      local idx=$((10#${idx_str}))
      if [[ ${idx} -gt ${max_idx} ]]; then
        max_idx=${idx}
      fi
    done < <(compgen -G "${RESOLUTIONS_DIR}/*.resol" || true)
  fi
  printf '%04d' $((max_idx + 1))
}

log_report_context() {
  local report_dir="$1"
  local context_file="${report_dir}/CONFLICT_CONTEXT.txt"
  [[ -f "${context_file}" ]] || return 0

  log ""
  log "Conflict context (${context_file}):"
  while IFS= read -r line; do
    [[ -z "${line}" ]] && continue
    log "  ${line}"
  done < "${context_file}"
}

# Compute per-hunk keys and write resolved hunks via Python.
# Args: <ours> <base> <theirs> <conflict_resolved> <filepath> <output_dir>
# Prints one hunk_key per line to stdout. Writes each hunk to output_dir/<key>.
compute_and_store_hunks() {
  local ours_file="$1"
  local base_file="$2"
  local theirs_file="$3"
  local conflict_resolved="$4"
  local filepath="$5"
  local output_dir="$6"

  python3 "${SCRIPT_DIR}/compute_hunk_resolution.py" \
    "${ours_file}" "${base_file}" "${theirs_file}" \
    "${conflict_resolved}" "${filepath}" "${output_dir}"
}

# Write JSON .resol metadata file
write_resol() {
  local hint="$1"
  local index="$2"
  shift 2
  # Remaining args are: filepath hunk_key [hunk_key ...] filepath hunk_key ...
  # Format: filepath followed by its hunk keys (separated by |||)
  local resol_file="${RESOLUTIONS_DIR}/${index}-${hint}.resol"

  {
    echo '{'
    echo "  \"hint\": \"${hint}\","
    echo '  "files": ['
    local first_file="true"
    while [[ $# -gt 0 ]]; do
      local fp="$1"
      local keys_str="$2"
      shift 2
      if [[ "${first_file}" == "true" ]]; then
        first_file="false"
      else
        echo ','
      fi
      echo '    {'
      echo "      \"filepath\": \"${fp}\","
      echo '      "hunk_keys": ['
      local first_key="true"
      IFS='|||' read -ra key_arr <<< "${keys_str}"
      for k in "${key_arr[@]}"; do
        [[ -z "${k}" ]] && continue
        if [[ "${first_key}" == "true" ]]; then
          first_key="false"
        else
          echo ','
        fi
        printf '        "%s"' "${k}"
      done
      echo ''
      echo '      ]'
      printf '    }'
    done
    echo ''
    echo '  ]'
    echo '}'
  } > "${resol_file}"

  log "Wrote: ${resol_file}"
}

main() {
  parse_args "$@"

  # Find all .conflict files in the report directory
  local conflict_files=()
  for f in "${REPORT_DIR}"/*.conflict; do
    [[ -f "${f}" ]] || continue
    conflict_files+=("${f}")
  done

  if [[ ${#conflict_files[@]} -eq 0 ]]; then
    die "No .conflict files found in ${REPORT_DIR}"
  fi

  log "Found ${#conflict_files[@]} conflict file(s) in ${REPORT_DIR}"
  log_report_context "${REPORT_DIR}"

  mkdir -p "${RESOLUTIONS_DIR}/contents"

  local recorded=0
  local skipped=0
  local resol_args=()

  for conflict_file in "${conflict_files[@]}"; do
    local base_name
    base_name="$(basename "${conflict_file}" .conflict)"
    local dir
    dir="$(dirname "${conflict_file}")"

    local filepath_file="${dir}/${base_name}.filepath"
    local ours_file="${dir}/${base_name}.ours"
    local base_file="${dir}/${base_name}.base"
    local theirs_file="${dir}/${base_name}.theirs"

    log ""
    log "Processing: ${base_name}"

    # Check for required files
    if [[ ! -f "${filepath_file}" ]]; then
      die "Missing ${filepath_file} — re-run the staging script (with updated version) using --dump-conflicts"
    fi
    local filepath
    filepath="$(<"${filepath_file}")"
    filepath="$(echo "${filepath}" | tr -d '\n\r')"

    if [[ ! -f "${ours_file}" ]]; then
      warn "Missing ${ours_file} — skipping"
      skipped=$((skipped + 1))
      continue
    fi
    if [[ ! -f "${base_file}" ]]; then
      warn "Missing ${base_file} — skipping"
      skipped=$((skipped + 1))
      continue
    fi
    if [[ ! -f "${theirs_file}" ]]; then
      warn "Missing ${theirs_file} — skipping"
      skipped=$((skipped + 1))
      continue
    fi

    # Validate: check for leftover conflict markers
    if ! validate_markers "${conflict_file}" "${ours_file}" "${theirs_file}" "${filepath}"; then
      warn "Skipping ${filepath} — leftover conflict markers found. Edit the .conflict file and re-run."
      skipped=$((skipped + 1))
      continue
    fi

    # Warn if resolved is identical to ours or theirs
    if cmp -s "${conflict_file}" "${ours_file}"; then
      warn "Resolved file is identical to ours for ${filepath} (accepted)"
    fi
    if cmp -s "${conflict_file}" "${theirs_file}"; then
      warn "Resolved file is identical to theirs for ${filepath} (accepted)"
    fi

    # Compute per-hunk keys and extract resolved hunks via Python
    local staging_dir="${RESOLUTIONS_DIR}/contents/.staging"
    rm -rf "${staging_dir}"
    local py_output
    if ! py_output="$(compute_and_store_hunks "${ours_file}" "${base_file}" "${theirs_file}" "${conflict_file}" "${filepath}" "${staging_dir}")"; then
      warn "Failed to compute hunk keys for ${filepath} — skipping"
      rm -rf "${staging_dir}"
      skipped=$((skipped + 1))
      continue
    fi

    # Process each hunk key (one per line from Python)
    local hunk_keys=""
    local hunk_count=0
    local hunk_skipped=0
    while IFS= read -r hunk_key; do
      [[ -z "${hunk_key}" ]] && continue
      local staged_path="${staging_dir}/${hunk_key}"
      local final_path="${RESOLUTIONS_DIR}/contents/${hunk_key}"

      if [[ -f "${final_path}" ]]; then
        if cmp -s "${staged_path}" "${final_path}"; then
          log "  Hunk already recorded (identical): ${hunk_key:0:32}..."
        else
          if [[ "${FORCE}" != "true" ]]; then
            warn "  Hunk exists with DIFFERENT content (${hunk_key:0:32}...). Use --force to overwrite."
            hunk_skipped=$((hunk_skipped + 1))
            continue
          fi
          cp "${staged_path}" "${final_path}"
          log "  Updated hunk: ${hunk_key:0:32}..."
        fi
      else
        cp "${staged_path}" "${final_path}"
        log "  Wrote hunk: ${hunk_key:0:32}..."
      fi

      if [[ -n "${hunk_keys}" ]]; then
        hunk_keys="${hunk_keys}|||${hunk_key}"
      else
        hunk_keys="${hunk_key}"
      fi
      hunk_count=$((hunk_count + 1))
    done <<< "${py_output}"

    rm -rf "${staging_dir}"

    if [[ ${hunk_count} -eq 0 ]]; then
      warn "No hunks recorded for ${filepath}"
      skipped=$((skipped + 1))
      continue
    fi

    if [[ ${hunk_skipped} -gt 0 ]]; then
      warn "${hunk_skipped} hunk(s) skipped for ${filepath} (use --force to overwrite)"
    fi

    log "  Recorded ${hunk_count} hunk(s) for ${filepath}"
    resol_args+=("${filepath}" "${hunk_keys}")
    recorded=$((recorded + 1))
  done

  log ""

  if [[ ${recorded} -eq 0 ]]; then
    if [[ ${skipped} -gt 0 ]]; then
      die "No resolutions recorded (${skipped} skipped). Fix the issues above and re-run."
    fi
    die "No resolutions to record."
  fi

  # Auto-generate hint if not provided
  if [[ -z "${HINT}" ]]; then
    HINT="$(auto_hint "${REPORT_DIR}")"
  fi

  # Check for existing .resol with same hint (reentrant support)
  local existing_resol=""
  local f
  while IFS= read -r f; do
    [[ -z "${f}" ]] && continue
    [[ -f "${f}" ]] || continue
    local base
    base="$(basename "${f}")"
    local existing_hint="${base#*-}"       # strip NNNN-
    existing_hint="${existing_hint%.resol}" # strip .resol
    if [[ "${existing_hint}" == "${HINT}" ]]; then
      existing_resol="${f}"
      break
    fi
  done < <(compgen -G "${RESOLUTIONS_DIR}/*.resol" || true)

  if [[ -n "${existing_resol}" ]]; then
    log "Updating existing .resol: ${existing_resol}"
    # Extract index from existing filename
    local base
    base="$(basename "${existing_resol}")"
    local index="${base%%-*}"
    write_resol "${HINT}" "${index}" "${resol_args[@]}"
  else
    # Find next index and write new .resol file
    local index
    index="$(next_resol_index)"
    write_resol "${HINT}" "${index}" "${resol_args[@]}"
  fi

  log ""
  log "Recorded ${recorded} resolution(s), ${skipped} skipped."
  log "Hint: ${HINT}"
  log ""
  log "To verify, re-run the staging script — you should see 'resolved from bank:' messages."
}

main "$@"
